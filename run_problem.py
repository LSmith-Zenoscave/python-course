#!/usr/bin/env python
"""
================================================================================
!!! DO NOT EDIT THIS FILE !!!

run_problem.py is a utility script that allows you to run a problem, and see
what your solution would output. This style of manual testing is important for
software when writing new code that you might not be sure how it should work!

For this course, you do not need to understand if the contents of this file.

================================================================================
"""

import math
import sys

from inspect import get_annotations, getmembers, isfunction
from pathlib import Path
from pkgutil import iter_modules


COMMANDS = {}


def _build_command_list():
    import assignments

    ispublic = lambda item: not item[0].startswith("_")

    for loader, name, _ in _iter_ns_modules(assignments.__path__, "."):
        module = loader.find_module(name).load_module(name)
        all_funcs = getmembers(module, isfunction)
        public_funcs = filter(ispublic, all_funcs)
        COMMANDS.update(public_funcs)

    COMMANDS["help"] = help
    COMMANDS["list"] = list


def _check_command(command):
    """Ensures a command is available, or lists available ones."""
    if command not in COMMANDS:
        print(f"'{command}' not found. The available commands are:")
        _list_commands()
        raise SystemExit(1)


def _iter_ns_modules(path, prefix):
    """Find packages recursively, including PEP420 packages"""
    namespace_packages = {}
    for path_root in path:
        for sub_path in Path(path_root).iterdir():
            if sub_path.is_dir() and not (sub_path / "__init__.py").exists():
                ns_paths = namespace_packages.setdefault(prefix + sub_path.name, [])
                ns_paths.append(str(sub_path))
    for name, paths in namespace_packages.items():
        # TODO: construct a loader somehow?
        yield from iter_modules(paths, name + ".")
        yield from _iter_ns_modules(paths, name + ".")


def _list_commands():
    """Lists available commands"""
    longest = math.ceil(max(map(len, COMMANDS)) / 2) * 2
    for command, func in COMMANDS.items():
        if doc := func.__doc__:
            desc = doc.split("\n", 2)[0]
            line = command.ljust(longest + 4) + desc
            print(line)


def _show_help(command: function):
    """Shows a helpful description of a command."""
    print(command.__doc__)


def help(command: str = ""):
    """Describes an available command.

    arguments:
        command: the command to describe as a string

    example:
        $ ./run_problem.py help "hello_world"
    """

    if not command or command not in COMMANDS:
        _show_help(help)
    else:
        _show_help(COMMANDS[command])


def list():
    """Shows all available commands.

    example:
        $ ./run_problem.py list
    """

    # Because run_problem uses docstring for help info,
    # list is run as an auxillary method for method reuse
    # and dependency de-coupling between help docstrings, and implementation
    _list_commands()


def _parse_args():
    problem, *args = sys.argv[1:]

    _check_command(problem)
    func = COMMANDS[problem]
    kwargs = {
        name: param(arg)
        for ((name, param), arg) in zip(get_annotations(func).items(), args)
    }

    return (func, kwargs)


def main():
    _build_command_list()

    if len(sys.argv) < 2:
        _list_commands()
        return

    func, kwargs = _parse_args()

    try:
        func(**kwargs)
    except TypeError:
        print("Missing or bad arguments provided")
        _show_help(func)
        raise SystemExit(2)


if __name__ == "__main__":
    main()
